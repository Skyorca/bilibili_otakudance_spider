#前三章的东西，写一个爬虫： 基本语法和存储文件规则

import requests

url = "http://www.bilibili.com"
r = requests.get(url)

#用字节流的方式写入，不管编码
f = open("bili.html", "wb")
f.write(r.content)
f.close()

#用字符串的方式写入，需要编码。因为文件是以字节流的形式存储的，而内容一开始是字符串的话就需要转化成字节流，encode编码
url = "http://www.bilibili.com"
r = requests.get(url)
r.encoding="utf8"
f = open("bili.html", "w+", encoding="utf8")
f.write(r.text)
f.close()

#从打开的文件里读一段东西出来，变成字符串，再存到另一个文件里
f = open("bili.html", 'r', encoding="utf8")
content = f.read(1000)#这样content的类型是字符串
g = open("test.txt", "w+",encoding="utf8")
g.write(content)
g.close()
f.close()


#文件命名：爬取巨量网页如何命名？

#方法一：用网页名字命名（网站主机最后一级文件夹下的文件）
url1 = "https://www.bilibili.com/video/av41735366" #here av41735366就是名字
filename1 = url1[url1.rfind('/')+1:]
print(filename1)
r1 = requests.get(url1)
r1.encoding = "utf8"
f = open(filename1+".html", "w+", encoding='utf8')
f.write(r1.text)
f.close
#从b站爬视频页面是出错的

#方法二： 域名+网页名字
#提取域名： url[start:end]
start = url1.find("//")+2
end   = url1.find('/', start)
domain = url1[start:end]
filename = domain + '_' + filename1
print(filename)
#一般网站url的组成方式是protocol + domain + path + file
#还有其他形式，例如protocol + domain + arguments ，这时可能要提取多项以消歧

#方法三 MD5签名对整个网页url hash为一串16进制的数值编码
import hashlib
md5_filename = hashlib.md5(url1.encode("utf8")).hexdigest()#md5对字节流hash，所以把字符串编码成字节流
print(md5_filename) #hexdigist()是为了把md5 HASH对象从内存里变成一个数值显示出来

#方法四 处理？
url[:url.find('?')] #?之后的是网页的动态参数，基本都不要了


#with语句： 类上下文管理器
#首先在类里面加入enter方法和exit方法，定义with语句块时类的入口和出口
class Trial(): #假设这个类就是文件file
    def __init__(self, filename, mode, encode): #实例化时调用，就是正常的构造函数
        print("__init__")
        self.filename = filename
        self.mode     = mode
        self.encode   = encode
    def __enter__(self): #进入with语句块时调用
        print("__enter__")
        print("filename:", self.filename)
        return self  #此处必有，因为不返回对象的话with语句的as+对象的对象就不存在了
    def __exit__(self, type, value, trace):#离开with语句块时调用，self之外的三个参数是规定的
        print("__exit__")
        print("type:", type)
        print("value:", value)
        print("trace:" ,trace)
        self.__close__() #离开时关闭句柄
    def __write__(self, byte_stream):
        print("__writing__")
        pass
    def __close__(self):
        print("__close__")
        pass

def __open__(filename, mode, encode):
    return Trial(filename, mode, encode)

with __open__("miku" ,'w','utf8') as f:
    f.__write__("vvv")

打印结果：
__init__
__enter__
filename: miku
__writing__
__exit__
type: None
value: None
trace: None
__close__
